#### 2. 如果原始数组的二分搜素对你来说太容易了，那么请试试这个演化后的版本：把t在数组x中的第一次出现的额位置返回给p（如果存在多个t的话，原始的算法会任意返回其中的一个）。要求代码对数组元素进行对数次比较（该任务可以在log_{2}n次比较之内完成）。

v0.1 思路：使用常规的二分查找，找到任一位置后，再前向遍历找到最靠前的位置。时间复杂度为为**O(logn + n/2)**。[代码详见](./src/question/Q2.java)

todo 参考答案：见9.3



#### 3. 编写并验证一个递归的二分搜索程序。代码和证明中的哪些部分与迭代版本的二分搜索程序向东？哪些程序部分发生了变化？

边界判断条件一致，但是条件成立后的操作不一致。迭代方式是改变上标或者下标的值，递归版本是将改变后的值继续调用当前方法进行递归判断。[代码详见](./src/question/Q3.java)



#### 4. 给你的二分搜索程序添加虚拟的“计时变量”来计算程序执行的比较次数，并使用程序验证技术来证明其运行时间确实是对数的。

使用Q3中的迭代版本的二分查找，初始化一个较大的有序数组和一个随机的key进行多次查找，计算查找次数和对数之间的关系。[代码详见](./src/question/Q4.java)



#### 6. [C. Scholten]David Gries在其*Science of Programming*中将下面的问题成为“咖啡罐问题”。给定一个盛有一些黑色豆子和一些白色豆子的咖啡罐以及一大堆“额外”的黑色豆子，重复下面的过程，直至罐中仅剩一颗豆子为止。证明该过程会终止。最后留在罐中的豆子颜色与最初罐中白色豆子和黑色豆子的数量有何函数关系？

```
从罐中随机选取两颗豆子，如果颜色相同，就将他们都扔掉并且放入一个额外的黑色豆子；如果颜色不同，就将白色的豆子放回罐中，而将黑色的豆子扔掉。
```

